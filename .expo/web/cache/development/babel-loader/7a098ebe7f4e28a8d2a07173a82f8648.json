{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\n\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\n\nvar _reactJsxRuntime = require(\"react/jsx-runtime\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar React = __importStar(require(\"react\"));\n\nvar MapMarker_1 = __importDefault(require(\"./MapMarker\"));\n\nvar MapPolyline_1 = __importDefault(require(\"./MapPolyline\"));\n\nvar MapPolygon_1 = __importDefault(require(\"./MapPolygon\"));\n\nvar Geojson = function Geojson(props) {\n  var geojson = props.geojson,\n      strokeColor = props.strokeColor,\n      fillColor = props.fillColor,\n      strokeWidth = props.strokeWidth,\n      color = props.color,\n      title = props.title,\n      image = props.image,\n      zIndex = props.zIndex,\n      _onPress = props.onPress,\n      lineCap = props.lineCap,\n      lineJoin = props.lineJoin,\n      tappable = props.tappable,\n      tracksViewChanges = props.tracksViewChanges,\n      miterLimit = props.miterLimit,\n      lineDashPhase = props.lineDashPhase,\n      lineDashPattern = props.lineDashPattern,\n      markerComponent = props.markerComponent;\n  var pointOverlays = makePointOverlays(geojson.features);\n  var lineOverlays = makeLineOverlays(geojson.features);\n  var polygonOverlays = makePolygonOverlays(geojson.features);\n  return _reactJsxRuntime.jsxs(React.Fragment, {\n    children: [pointOverlays.map(function (overlay, index) {\n      var _overlay$feature$prop;\n\n      var markerColor = getColor(color, overlay, 'marker-color');\n      var pointOverlayTracksViewChanges = ((_overlay$feature$prop = overlay.feature.properties) == null ? void 0 : _overlay$feature$prop.tracksViewChanges) || tracksViewChanges;\n      return _reactJsxRuntime.jsx(MapMarker_1.default, {\n        coordinate: overlay.coordinates,\n        tracksViewChanges: pointOverlayTracksViewChanges,\n        image: image,\n        title: title,\n        pinColor: markerColor,\n        zIndex: zIndex,\n        onPress: function onPress() {\n          return _onPress && _onPress(overlay);\n        },\n        children: markerComponent\n      }, index);\n    }), lineOverlays.map(function (overlay, index) {\n      var lineStrokeColor = getColor(strokeColor, overlay, 'stroke');\n      var lineStrokeWidth = getStrokeWidth(strokeWidth, overlay);\n      return _reactJsxRuntime.jsx(MapPolyline_1.default, {\n        coordinates: overlay.coordinates,\n        strokeColor: lineStrokeColor,\n        strokeWidth: lineStrokeWidth,\n        lineDashPhase: lineDashPhase,\n        lineDashPattern: lineDashPattern,\n        lineCap: lineCap,\n        lineJoin: lineJoin,\n        miterLimit: miterLimit,\n        zIndex: zIndex,\n        tappable: tappable,\n        onPress: function onPress() {\n          return _onPress && _onPress(overlay);\n        }\n      }, index);\n    }), polygonOverlays.map(function (overlay, index) {\n      var polygonFillColor = getColor(fillColor, overlay, 'fill');\n      var lineStrokeColor = getColor(strokeColor, overlay, 'stroke');\n      var lineStrokeWidth = getStrokeWidth(strokeWidth, overlay);\n      return _reactJsxRuntime.jsx(MapPolygon_1.default, {\n        coordinates: overlay.coordinates,\n        holes: overlay.holes,\n        strokeColor: lineStrokeColor,\n        fillColor: polygonFillColor,\n        strokeWidth: lineStrokeWidth,\n        tappable: tappable,\n        onPress: function onPress() {\n          return _onPress && _onPress(overlay);\n        },\n        zIndex: zIndex\n      }, index);\n    })]\n  });\n};\n\nexports.default = Geojson;\n\nvar makePointOverlays = function makePointOverlays(features) {\n  return features.filter(isAnyPointFeature).map(function (feature) {\n    return makeCoordinatesForAnyPoint(feature.geometry).map(function (coordinates) {\n      return makeOverlayForAnyPoint(coordinates, feature);\n    });\n  }).reduce(function (prev, curr) {\n    return prev.concat(curr);\n  }, []).map(function (overlay) {\n    return _objectSpread(_objectSpread({}, overlay), {}, {\n      type: 'point'\n    });\n  });\n};\n\nvar makeLineOverlays = function makeLineOverlays(features) {\n  return features.filter(isAnyLineStringFeature).map(function (feature) {\n    return makeCoordinatesForAnyLine(feature.geometry).map(function (coordinates) {\n      return makeOverlayForAnyLine(coordinates, feature);\n    });\n  }).reduce(function (prev, curr) {\n    return prev.concat(curr);\n  }, []).map(function (overlay) {\n    return _objectSpread(_objectSpread({}, overlay), {}, {\n      type: 'polyline'\n    });\n  });\n};\n\nvar makePolygonOverlays = function makePolygonOverlays(features) {\n  var multipolygons = features.filter(isMultiPolygonFeature).map(function (feature) {\n    return makeCoordinatesForMultiPolygon(feature.geometry).map(function (coordinates) {\n      return makeOverlayForAnyPolygon(coordinates, feature);\n    });\n  }).reduce(function (prev, curr) {\n    return prev.concat(curr);\n  }, []).map(function (overlay) {\n    return _objectSpread(_objectSpread({}, overlay), {}, {\n      type: 'polygon'\n    });\n  });\n  var polygons = features.filter(isPolygonFeature).map(function (feature) {\n    return makeOverlayForAnyPolygon(makeCoordinatesForPolygon(feature.geometry), feature);\n  }).reduce(function (prev, curr) {\n    return prev.concat(curr);\n  }, []).map(function (overlay) {\n    return _objectSpread(_objectSpread({}, overlay), {}, {\n      type: 'polygon'\n    });\n  });\n  return polygons.concat(multipolygons);\n};\n\nvar makeOverlayForAnyPoint = function makeOverlayForAnyPoint(coordinates, feature) {\n  return {\n    feature: feature,\n    coordinates: coordinates\n  };\n};\n\nvar makeOverlayForAnyLine = function makeOverlayForAnyLine(coordinates, feature) {\n  return {\n    feature: feature,\n    coordinates: coordinates\n  };\n};\n\nvar makeOverlayForAnyPolygon = function makeOverlayForAnyPolygon(coordinates, feature) {\n  return {\n    feature: feature,\n    coordinates: coordinates[0],\n    holes: coordinates.length > 1 ? coordinates.slice(1) : undefined\n  };\n};\n\nvar makePoint = function makePoint(c) {\n  return {\n    latitude: c[1],\n    longitude: c[0]\n  };\n};\n\nvar makeLine = function makeLine(l) {\n  return l.map(makePoint);\n};\n\nvar makeCoordinatesForAnyPoint = function makeCoordinatesForAnyPoint(geometry) {\n  if (geometry.type === 'Point') {\n    return [makePoint(geometry.coordinates)];\n  }\n\n  return geometry.coordinates.map(makePoint);\n};\n\nvar makeCoordinatesForAnyLine = function makeCoordinatesForAnyLine(geometry) {\n  if (geometry.type === 'LineString') {\n    return [makeLine(geometry.coordinates)];\n  }\n\n  return geometry.coordinates.map(makeLine);\n};\n\nvar makeCoordinatesForPolygon = function makeCoordinatesForPolygon(geometry) {\n  return geometry.coordinates.map(makeLine);\n};\n\nvar makeCoordinatesForMultiPolygon = function makeCoordinatesForMultiPolygon(geometry) {\n  return geometry.coordinates.map(function (p) {\n    return p.map(makeLine);\n  });\n};\n\nvar getRgbaFromHex = function getRgbaFromHex(hex) {\n  var alpha = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var matchArray = hex.match(/\\w\\w/g);\n\n  if (!matchArray || matchArray.length < 3) {\n    throw new Error('Invalid hex string');\n  }\n\n  var _matchArray$map = matchArray.map(function (x) {\n    var subColor = parseInt(x, 16);\n\n    if (Number.isNaN(subColor)) {\n      throw new Error('Invalid hex string');\n    }\n\n    return subColor;\n  }),\n      _matchArray$map2 = _slicedToArray(_matchArray$map, 3),\n      r = _matchArray$map2[0],\n      g = _matchArray$map2[1],\n      b = _matchArray$map2[2];\n\n  return \"rgba(\" + r + \",\" + g + \",\" + b + \",\" + alpha + \")\";\n};\n\nvar getColor = function getColor(prop, overlay, colorType) {\n  var _overlay$feature$prop2;\n\n  if (prop) {\n    return prop;\n  }\n\n  var color = (_overlay$feature$prop2 = overlay.feature.properties) == null ? void 0 : _overlay$feature$prop2[colorType];\n\n  if (color) {\n    var _overlay$feature$prop3;\n\n    var opacityProperty = colorType + '-opacity';\n    var alpha = (_overlay$feature$prop3 = overlay.feature.properties) == null ? void 0 : _overlay$feature$prop3[opacityProperty];\n\n    if (alpha && alpha !== '0' && color[0] === '#') {\n      color = getRgbaFromHex(color, alpha);\n    }\n\n    return color;\n  }\n\n  return undefined;\n};\n\nvar getStrokeWidth = function getStrokeWidth(prop, overlay) {\n  var _overlay$feature$prop4;\n\n  if (prop) {\n    return prop;\n  }\n\n  return (_overlay$feature$prop4 = overlay.feature.properties) == null ? void 0 : _overlay$feature$prop4['stroke-width'];\n};\n\nvar isPointFeature = function isPointFeature(feature) {\n  return feature.geometry.type === 'Point';\n};\n\nvar isMultiPointFeature = function isMultiPointFeature(feature) {\n  return feature.geometry.type === 'MultiPoint';\n};\n\nvar isAnyPointFeature = function isAnyPointFeature(feature) {\n  return isPointFeature(feature) || isMultiPointFeature(feature);\n};\n\nvar isLineStringFeature = function isLineStringFeature(feature) {\n  return feature.geometry.type === 'LineString';\n};\n\nvar isMultiLineStringFeature = function isMultiLineStringFeature(feature) {\n  return feature.geometry.type === 'MultiLineString';\n};\n\nvar isAnyLineStringFeature = function isAnyLineStringFeature(feature) {\n  return isLineStringFeature(feature) || isMultiLineStringFeature(feature);\n};\n\nvar isPolygonFeature = function isPolygonFeature(feature) {\n  return feature.geometry.type === 'Polygon';\n};\n\nvar isMultiPolygonFeature = function isMultiPolygonFeature(feature) {\n  return feature.geometry.type === 'MultiPolygon';\n};","map":{"version":3,"sources":["/Users/jasminebabayara/Documents/Projects/ReactNative/Food-Delivery-App/node_modules/react-native-maps/lib/Geojson.js"],"names":["__createBinding","Object","create","o","m","k","k2","undefined","desc","getOwnPropertyDescriptor","__esModule","writable","configurable","enumerable","get","defineProperty","__setModuleDefault","v","value","__importStar","mod","result","prototype","hasOwnProperty","call","__importDefault","exports","React","require","MapMarker_1","MapPolyline_1","MapPolygon_1","Geojson","props","geojson","strokeColor","fillColor","strokeWidth","color","title","image","zIndex","onPress","lineCap","lineJoin","tappable","tracksViewChanges","miterLimit","lineDashPhase","lineDashPattern","markerComponent","pointOverlays","makePointOverlays","features","lineOverlays","makeLineOverlays","polygonOverlays","makePolygonOverlays","map","overlay","index","markerColor","getColor","pointOverlayTracksViewChanges","feature","properties","coordinates","lineStrokeColor","lineStrokeWidth","getStrokeWidth","polygonFillColor","holes","default","filter","isAnyPointFeature","makeCoordinatesForAnyPoint","geometry","makeOverlayForAnyPoint","reduce","prev","curr","concat","type","isAnyLineStringFeature","makeCoordinatesForAnyLine","makeOverlayForAnyLine","multipolygons","isMultiPolygonFeature","makeCoordinatesForMultiPolygon","makeOverlayForAnyPolygon","polygons","isPolygonFeature","makeCoordinatesForPolygon","length","slice","makePoint","c","latitude","longitude","makeLine","l","p","getRgbaFromHex","hex","alpha","matchArray","match","Error","x","subColor","parseInt","Number","isNaN","r","g","b","prop","colorType","opacityProperty","isPointFeature","isMultiPointFeature","isLineStringFeature","isMultiLineStringFeature"],"mappings":"AAAA;;;;;;;;;;;;AACA,IAAIA,eAAe,GAAI,QAAQ,KAAKA,eAAd,KAAmCC,MAAM,CAACC,MAAP,GAAiB,UAASC,CAAT,EAAYC,CAAZ,EAAeC,CAAf,EAAkBC,EAAlB,EAAsB;AAC5F,MAAIA,EAAE,KAAKC,SAAX,EAAsBD,EAAE,GAAGD,CAAL;AACtB,MAAIG,IAAI,GAAGP,MAAM,CAACQ,wBAAP,CAAgCL,CAAhC,EAAmCC,CAAnC,CAAX;;AACA,MAAI,CAACG,IAAD,KAAU,SAASA,IAAT,GAAgB,CAACJ,CAAC,CAACM,UAAnB,GAAgCF,IAAI,CAACG,QAAL,IAAiBH,IAAI,CAACI,YAAhE,CAAJ,EAAmF;AACjFJ,IAAAA,IAAI,GAAG;AAAEK,MAAAA,UAAU,EAAE,IAAd;AAAoBC,MAAAA,GAAG,EAAE,eAAW;AAAE,eAAOV,CAAC,CAACC,CAAD,CAAR;AAAc;AAApD,KAAP;AACD;;AACDJ,EAAAA,MAAM,CAACc,cAAP,CAAsBZ,CAAtB,EAAyBG,EAAzB,EAA6BE,IAA7B;AACH,CAPwD,GAOnD,UAASL,CAAT,EAAYC,CAAZ,EAAeC,CAAf,EAAkBC,EAAlB,EAAsB;AACxB,MAAIA,EAAE,KAAKC,SAAX,EAAsBD,EAAE,GAAGD,CAAL;AACtBF,EAAAA,CAAC,CAACG,EAAD,CAAD,GAAQF,CAAC,CAACC,CAAD,CAAT;AACH,CAVqB,CAAtB;;AAWA,IAAIW,kBAAkB,GAAI,QAAQ,KAAKA,kBAAd,KAAsCf,MAAM,CAACC,MAAP,GAAiB,UAASC,CAAT,EAAYc,CAAZ,EAAe;AAC3FhB,EAAAA,MAAM,CAACc,cAAP,CAAsBZ,CAAtB,EAAyB,SAAzB,EAAoC;AAAEU,IAAAA,UAAU,EAAE,IAAd;AAAoBK,IAAAA,KAAK,EAAED;AAA3B,GAApC;AACH,CAF8D,GAE1D,UAASd,CAAT,EAAYc,CAAZ,EAAe;AAChBd,EAAAA,CAAC,CAAC,SAAD,CAAD,GAAec,CAAf;AACH,CAJwB,CAAzB;;AAKA,IAAIE,YAAY,GAAI,QAAQ,KAAKA,YAAd,IAA+B,UAAUC,GAAV,EAAe;AAC7D,MAAIA,GAAG,IAAIA,GAAG,CAACV,UAAf,EAA2B,OAAOU,GAAP;AAC3B,MAAIC,MAAM,GAAG,EAAb;AACA,MAAID,GAAG,IAAI,IAAX,EAAiB,KAAK,IAAIf,CAAT,IAAce,GAAd;AAAmB,QAAIf,CAAC,KAAK,SAAN,IAAmBJ,MAAM,CAACqB,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCJ,GAArC,EAA0Cf,CAA1C,CAAvB,EAAqEL,eAAe,CAACqB,MAAD,EAASD,GAAT,EAAcf,CAAd,CAAf;AAAxF;;AACjBW,EAAAA,kBAAkB,CAACK,MAAD,EAASD,GAAT,CAAlB;;AACA,SAAOC,MAAP;AACH,CAND;;AAOA,IAAII,eAAe,GAAI,QAAQ,KAAKA,eAAd,IAAkC,UAAUL,GAAV,EAAe;AACnE,SAAQA,GAAG,IAAIA,GAAG,CAACV,UAAZ,GAA0BU,GAA1B,GAAgC;AAAE,eAAWA;AAAb,GAAvC;AACH,CAFD;;AAGAnB,MAAM,CAACc,cAAP,CAAsBW,OAAtB,EAA+B,YAA/B,EAA6C;AAAER,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AACA,IAAMS,KAAK,GAAGR,YAAY,CAACS,OAAO,CAAC,OAAD,CAAR,CAA1B;;AACA,IAAMC,WAAW,GAAGJ,eAAe,CAACG,OAAO,eAAR,CAAnC;;AACA,IAAME,aAAa,GAAGL,eAAe,CAACG,OAAO,iBAAR,CAArC;;AACA,IAAMG,YAAY,GAAGN,eAAe,CAACG,OAAO,gBAAR,CAApC;;AACA,IAAMI,OAAO,GAAG,SAAVA,OAAU,CAACC,KAAD,EAAW;AACvB,MAAQC,OAAR,GAA6MD,KAA7M,CAAQC,OAAR;AAAA,MAAiBC,WAAjB,GAA6MF,KAA7M,CAAiBE,WAAjB;AAAA,MAA8BC,SAA9B,GAA6MH,KAA7M,CAA8BG,SAA9B;AAAA,MAAyCC,WAAzC,GAA6MJ,KAA7M,CAAyCI,WAAzC;AAAA,MAAsDC,KAAtD,GAA6ML,KAA7M,CAAsDK,KAAtD;AAAA,MAA6DC,KAA7D,GAA6MN,KAA7M,CAA6DM,KAA7D;AAAA,MAAoEC,KAApE,GAA6MP,KAA7M,CAAoEO,KAApE;AAAA,MAA2EC,MAA3E,GAA6MR,KAA7M,CAA2EQ,MAA3E;AAAA,MAAmFC,QAAnF,GAA6MT,KAA7M,CAAmFS,OAAnF;AAAA,MAA4FC,OAA5F,GAA6MV,KAA7M,CAA4FU,OAA5F;AAAA,MAAqGC,QAArG,GAA6MX,KAA7M,CAAqGW,QAArG;AAAA,MAA+GC,QAA/G,GAA6MZ,KAA7M,CAA+GY,QAA/G;AAAA,MAAyHC,iBAAzH,GAA6Mb,KAA7M,CAAyHa,iBAAzH;AAAA,MAA4IC,UAA5I,GAA6Md,KAA7M,CAA4Ic,UAA5I;AAAA,MAAwJC,aAAxJ,GAA6Mf,KAA7M,CAAwJe,aAAxJ;AAAA,MAAuKC,eAAvK,GAA6MhB,KAA7M,CAAuKgB,eAAvK;AAAA,MAAwLC,eAAxL,GAA6MjB,KAA7M,CAAwLiB,eAAxL;AACA,MAAMC,aAAa,GAAGC,iBAAiB,CAAClB,OAAO,CAACmB,QAAT,CAAvC;AACA,MAAMC,YAAY,GAAGC,gBAAgB,CAACrB,OAAO,CAACmB,QAAT,CAArC;AACA,MAAMG,eAAe,GAAGC,mBAAmB,CAACvB,OAAO,CAACmB,QAAT,CAA3C;AACA,SAAQ,sBAAC,KAAD,CAAO,QAAP;AAAA,eACLF,aAAa,CAACO,GAAd,CAAkB,UAACC,OAAD,EAAUC,KAAV,EAAoB;AAAA;;AACjC,UAAMC,WAAW,GAAGC,QAAQ,CAACxB,KAAD,EAAQqB,OAAR,EAAiB,cAAjB,CAA5B;AACA,UAAMI,6BAA6B,GAAG,0BAAAJ,OAAO,CAACK,OAAR,CAAgBC,UAAhB,2CAA4BnB,iBAA5B,KAAiDA,iBAAvF;AACA,aAAQ,qBAAC,WAAD,CAAa,OAAb;AAAiC,QAAA,UAAU,EAAEa,OAAO,CAACO,WAArD;AAAkE,QAAA,iBAAiB,EAAEH,6BAArF;AAAoH,QAAA,KAAK,EAAEvB,KAA3H;AAAkI,QAAA,KAAK,EAAED,KAAzI;AAAgJ,QAAA,QAAQ,EAAEsB,WAA1J;AAAuK,QAAA,MAAM,EAAEpB,MAA/K;AAAuL,QAAA,OAAO,EAAE;AAAA,iBAAMC,QAAO,IAAIA,QAAO,CAACiB,OAAD,CAAxB;AAAA,SAAhM;AAAA,kBACPT;AADO,SAA0BU,KAA1B,CAAR;AAGH,KANF,CADK,EAQLN,YAAY,CAACI,GAAb,CAAiB,UAACC,OAAD,EAAUC,KAAV,EAAoB;AAChC,UAAMO,eAAe,GAAGL,QAAQ,CAAC3B,WAAD,EAAcwB,OAAd,EAAuB,QAAvB,CAAhC;AACA,UAAMS,eAAe,GAAGC,cAAc,CAAChC,WAAD,EAAcsB,OAAd,CAAtC;AACA,aAAQ,qBAAC,aAAD,CAAe,OAAf;AAAmC,QAAA,WAAW,EAAEA,OAAO,CAACO,WAAxD;AAAqE,QAAA,WAAW,EAAEC,eAAlF;AAAmG,QAAA,WAAW,EAAEC,eAAhH;AAAiI,QAAA,aAAa,EAAEpB,aAAhJ;AAA+J,QAAA,eAAe,EAAEC,eAAhL;AAAiM,QAAA,OAAO,EAAEN,OAA1M;AAAmN,QAAA,QAAQ,EAAEC,QAA7N;AAAuO,QAAA,UAAU,EAAEG,UAAnP;AAA+P,QAAA,MAAM,EAAEN,MAAvQ;AAA+Q,QAAA,QAAQ,EAAEI,QAAzR;AAAmS,QAAA,OAAO,EAAE;AAAA,iBAAMH,QAAO,IAAIA,QAAO,CAACiB,OAAD,CAAxB;AAAA;AAA5S,SAA4BC,KAA5B,CAAR;AACH,KAJF,CARK,EAaLJ,eAAe,CAACE,GAAhB,CAAoB,UAACC,OAAD,EAAUC,KAAV,EAAoB;AACnC,UAAMU,gBAAgB,GAAGR,QAAQ,CAAC1B,SAAD,EAAYuB,OAAZ,EAAqB,MAArB,CAAjC;AACA,UAAMQ,eAAe,GAAGL,QAAQ,CAAC3B,WAAD,EAAcwB,OAAd,EAAuB,QAAvB,CAAhC;AACA,UAAMS,eAAe,GAAGC,cAAc,CAAChC,WAAD,EAAcsB,OAAd,CAAtC;AACA,aAAQ,qBAAC,YAAD,CAAc,OAAd;AAAkC,QAAA,WAAW,EAAEA,OAAO,CAACO,WAAvD;AAAoE,QAAA,KAAK,EAAEP,OAAO,CAACY,KAAnF;AAA0F,QAAA,WAAW,EAAEJ,eAAvG;AAAwH,QAAA,SAAS,EAAEG,gBAAnI;AAAqJ,QAAA,WAAW,EAAEF,eAAlK;AAAmL,QAAA,QAAQ,EAAEvB,QAA7L;AAAuM,QAAA,OAAO,EAAE;AAAA,iBAAMH,QAAO,IAAIA,QAAO,CAACiB,OAAD,CAAxB;AAAA,SAAhN;AAAmP,QAAA,MAAM,EAAElB;AAA3P,SAA2BmB,KAA3B,CAAR;AACH,KALF,CAbK;AAAA,IAAR;AAoBH,CAzBD;;AA0BAlC,OAAO,CAAC8C,OAAR,GAAkBxC,OAAlB;;AACA,IAAMoB,iBAAiB,GAAG,SAApBA,iBAAoB,CAACC,QAAD,EAAc;AACpC,SAAOA,QAAQ,CACVoB,MADE,CACKC,iBADL,EAEFhB,GAFE,CAEE,UAAAM,OAAO;AAAA,WAAIW,0BAA0B,CAACX,OAAO,CAACY,QAAT,CAA1B,CAA6ClB,GAA7C,CAAiD,UAAAQ,WAAW;AAAA,aAAIW,sBAAsB,CAACX,WAAD,EAAcF,OAAd,CAA1B;AAAA,KAA5D,CAAJ;AAAA,GAFT,EAGFc,MAHE,CAGK,UAACC,IAAD,EAAOC,IAAP;AAAA,WAAgBD,IAAI,CAACE,MAAL,CAAYD,IAAZ,CAAhB;AAAA,GAHL,EAGwC,EAHxC,EAIFtB,GAJE,CAIE,UAAAC,OAAO;AAAA,2CAAUA,OAAV;AAAmBuB,MAAAA,IAAI,EAAE;AAAzB;AAAA,GAJT,CAAP;AAKH,CAND;;AAOA,IAAM3B,gBAAgB,GAAG,SAAnBA,gBAAmB,CAACF,QAAD,EAAc;AACnC,SAAOA,QAAQ,CACVoB,MADE,CACKU,sBADL,EAEFzB,GAFE,CAEE,UAAAM,OAAO;AAAA,WAAIoB,yBAAyB,CAACpB,OAAO,CAACY,QAAT,CAAzB,CAA4ClB,GAA5C,CAAgD,UAAAQ,WAAW;AAAA,aAAImB,qBAAqB,CAACnB,WAAD,EAAcF,OAAd,CAAzB;AAAA,KAA3D,CAAJ;AAAA,GAFT,EAGFc,MAHE,CAGK,UAACC,IAAD,EAAOC,IAAP;AAAA,WAAgBD,IAAI,CAACE,MAAL,CAAYD,IAAZ,CAAhB;AAAA,GAHL,EAGwC,EAHxC,EAIFtB,GAJE,CAIE,UAAAC,OAAO;AAAA,2CAAUA,OAAV;AAAmBuB,MAAAA,IAAI,EAAE;AAAzB;AAAA,GAJT,CAAP;AAKH,CAND;;AAOA,IAAMzB,mBAAmB,GAAG,SAAtBA,mBAAsB,CAACJ,QAAD,EAAc;AACtC,MAAMiC,aAAa,GAAGjC,QAAQ,CACzBoB,MADiB,CACVc,qBADU,EAEjB7B,GAFiB,CAEb,UAAAM,OAAO;AAAA,WAAIwB,8BAA8B,CAACxB,OAAO,CAACY,QAAT,CAA9B,CAAiDlB,GAAjD,CAAqD,UAAAQ,WAAW;AAAA,aAAIuB,wBAAwB,CAACvB,WAAD,EAAcF,OAAd,CAA5B;AAAA,KAAhE,CAAJ;AAAA,GAFM,EAGjBc,MAHiB,CAGV,UAACC,IAAD,EAAOC,IAAP;AAAA,WAAgBD,IAAI,CAACE,MAAL,CAAYD,IAAZ,CAAhB;AAAA,GAHU,EAGyB,EAHzB,EAIjBtB,GAJiB,CAIb,UAAAC,OAAO;AAAA,2CAAUA,OAAV;AAAmBuB,MAAAA,IAAI,EAAE;AAAzB;AAAA,GAJM,CAAtB;AAKA,MAAMQ,QAAQ,GAAGrC,QAAQ,CACpBoB,MADY,CACLkB,gBADK,EAEZjC,GAFY,CAER,UAAAM,OAAO;AAAA,WAAIyB,wBAAwB,CAACG,yBAAyB,CAAC5B,OAAO,CAACY,QAAT,CAA1B,EAA8CZ,OAA9C,CAA5B;AAAA,GAFC,EAGZc,MAHY,CAGL,UAACC,IAAD,EAAOC,IAAP;AAAA,WAAgBD,IAAI,CAACE,MAAL,CAAYD,IAAZ,CAAhB;AAAA,GAHK,EAG8B,EAH9B,EAIZtB,GAJY,CAIR,UAAAC,OAAO;AAAA,2CAAUA,OAAV;AAAmBuB,MAAAA,IAAI,EAAE;AAAzB;AAAA,GAJC,CAAjB;AAKA,SAAOQ,QAAQ,CAACT,MAAT,CAAgBK,aAAhB,CAAP;AACH,CAZD;;AAaA,IAAMT,sBAAsB,GAAG,SAAzBA,sBAAyB,CAACX,WAAD,EAAcF,OAAd,EAA0B;AACrD,SAAO;AAAEA,IAAAA,OAAO,EAAPA,OAAF;AAAWE,IAAAA,WAAW,EAAXA;AAAX,GAAP;AACH,CAFD;;AAGA,IAAMmB,qBAAqB,GAAG,SAAxBA,qBAAwB,CAACnB,WAAD,EAAcF,OAAd,EAA0B;AACpD,SAAO;AAAEA,IAAAA,OAAO,EAAPA,OAAF;AAAWE,IAAAA,WAAW,EAAXA;AAAX,GAAP;AACH,CAFD;;AAGA,IAAMuB,wBAAwB,GAAG,SAA3BA,wBAA2B,CAACvB,WAAD,EAAcF,OAAd,EAA0B;AACvD,SAAO;AACHA,IAAAA,OAAO,EAAPA,OADG;AAEHE,IAAAA,WAAW,EAAEA,WAAW,CAAC,CAAD,CAFrB;AAGHK,IAAAA,KAAK,EAAEL,WAAW,CAAC2B,MAAZ,GAAqB,CAArB,GAAyB3B,WAAW,CAAC4B,KAAZ,CAAkB,CAAlB,CAAzB,GAAgDvF;AAHpD,GAAP;AAKH,CAND;;AAOA,IAAMwF,SAAS,GAAG,SAAZA,SAAY,CAACC,CAAD;AAAA,SAAQ;AACtBC,IAAAA,QAAQ,EAAED,CAAC,CAAC,CAAD,CADW;AAEtBE,IAAAA,SAAS,EAAEF,CAAC,CAAC,CAAD;AAFU,GAAR;AAAA,CAAlB;;AAIA,IAAMG,QAAQ,GAAG,SAAXA,QAAW,CAACC,CAAD;AAAA,SAAOA,CAAC,CAAC1C,GAAF,CAAMqC,SAAN,CAAP;AAAA,CAAjB;;AACA,IAAMpB,0BAA0B,GAAG,SAA7BA,0BAA6B,CAACC,QAAD,EAAc;AAC7C,MAAIA,QAAQ,CAACM,IAAT,KAAkB,OAAtB,EAA+B;AAC3B,WAAO,CAACa,SAAS,CAACnB,QAAQ,CAACV,WAAV,CAAV,CAAP;AACH;;AACD,SAAOU,QAAQ,CAACV,WAAT,CAAqBR,GAArB,CAAyBqC,SAAzB,CAAP;AACH,CALD;;AAMA,IAAMX,yBAAyB,GAAG,SAA5BA,yBAA4B,CAACR,QAAD,EAAc;AAC5C,MAAIA,QAAQ,CAACM,IAAT,KAAkB,YAAtB,EAAoC;AAChC,WAAO,CAACiB,QAAQ,CAACvB,QAAQ,CAACV,WAAV,CAAT,CAAP;AACH;;AACD,SAAOU,QAAQ,CAACV,WAAT,CAAqBR,GAArB,CAAyByC,QAAzB,CAAP;AACH,CALD;;AAMA,IAAMP,yBAAyB,GAAG,SAA5BA,yBAA4B,CAAChB,QAAD,EAAc;AAC5C,SAAOA,QAAQ,CAACV,WAAT,CAAqBR,GAArB,CAAyByC,QAAzB,CAAP;AACH,CAFD;;AAGA,IAAMX,8BAA8B,GAAG,SAAjCA,8BAAiC,CAACZ,QAAD,EAAc;AACjD,SAAOA,QAAQ,CAACV,WAAT,CAAqBR,GAArB,CAAyB,UAAA2C,CAAC;AAAA,WAAIA,CAAC,CAAC3C,GAAF,CAAMyC,QAAN,CAAJ;AAAA,GAA1B,CAAP;AACH,CAFD;;AAGA,IAAMG,cAAc,GAAG,SAAjBA,cAAiB,CAACC,GAAD,EAAoB;AAAA,MAAdC,KAAc,uEAAN,CAAM;AACvC,MAAMC,UAAU,GAAGF,GAAG,CAACG,KAAJ,CAAU,OAAV,CAAnB;;AACA,MAAI,CAACD,UAAD,IAAeA,UAAU,CAACZ,MAAX,GAAoB,CAAvC,EAA0C;AACtC,UAAM,IAAIc,KAAJ,CAAU,oBAAV,CAAN;AACH;;AACD,wBAAkBF,UAAU,CAAC/C,GAAX,CAAe,UAAAkD,CAAC,EAAI;AAClC,QAAMC,QAAQ,GAAGC,QAAQ,CAACF,CAAD,EAAI,EAAJ,CAAzB;;AACA,QAAIG,MAAM,CAACC,KAAP,CAAaH,QAAb,CAAJ,EAA4B;AACxB,YAAM,IAAIF,KAAJ,CAAU,oBAAV,CAAN;AACH;;AACD,WAAOE,QAAP;AACH,GANiB,CAAlB;AAAA;AAAA,MAAOI,CAAP;AAAA,MAAUC,CAAV;AAAA,MAAaC,CAAb;;AAOA,mBAAeF,CAAf,SAAoBC,CAApB,SAAyBC,CAAzB,SAA8BX,KAA9B;AACH,CAbD;;AAcA,IAAM1C,QAAQ,GAAG,SAAXA,QAAW,CAACsD,IAAD,EAAOzD,OAAP,EAAgB0D,SAAhB,EAA8B;AAAA;;AAC3C,MAAID,IAAJ,EAAU;AACN,WAAOA,IAAP;AACH;;AACD,MAAI9E,KAAK,6BAAGqB,OAAO,CAACK,OAAR,CAAgBC,UAAnB,qBAAG,uBAA6BoD,SAA7B,CAAZ;;AACA,MAAI/E,KAAJ,EAAW;AAAA;;AACP,QAAMgF,eAAe,GAAGD,SAAS,GAAG,UAApC;AACA,QAAMb,KAAK,6BAAG7C,OAAO,CAACK,OAAR,CAAgBC,UAAnB,qBAAG,uBAA6BqD,eAA7B,CAAd;;AACA,QAAId,KAAK,IAAIA,KAAK,KAAK,GAAnB,IAA0BlE,KAAK,CAAC,CAAD,CAAL,KAAa,GAA3C,EAAgD;AAC5CA,MAAAA,KAAK,GAAGgE,cAAc,CAAChE,KAAD,EAAQkE,KAAR,CAAtB;AACH;;AACD,WAAOlE,KAAP;AACH;;AACD,SAAO/B,SAAP;AACH,CAdD;;AAeA,IAAM8D,cAAc,GAAG,SAAjBA,cAAiB,CAAC+C,IAAD,EAAOzD,OAAP,EAAmB;AAAA;;AACtC,MAAIyD,IAAJ,EAAU;AACN,WAAOA,IAAP;AACH;;AACD,mCAAOzD,OAAO,CAACK,OAAR,CAAgBC,UAAvB,qBAAO,uBAA6B,cAA7B,CAAP;AACH,CALD;;AAOA,IAAMsD,cAAc,GAAG,SAAjBA,cAAiB,CAACvD,OAAD;AAAA,SAAaA,OAAO,CAACY,QAAR,CAAiBM,IAAjB,KAA0B,OAAvC;AAAA,CAAvB;;AACA,IAAMsC,mBAAmB,GAAG,SAAtBA,mBAAsB,CAACxD,OAAD;AAAA,SAAaA,OAAO,CAACY,QAAR,CAAiBM,IAAjB,KAA0B,YAAvC;AAAA,CAA5B;;AACA,IAAMR,iBAAiB,GAAG,SAApBA,iBAAoB,CAACV,OAAD;AAAA,SAAauD,cAAc,CAACvD,OAAD,CAAd,IAA2BwD,mBAAmB,CAACxD,OAAD,CAA3D;AAAA,CAA1B;;AACA,IAAMyD,mBAAmB,GAAG,SAAtBA,mBAAsB,CAACzD,OAAD;AAAA,SAAaA,OAAO,CAACY,QAAR,CAAiBM,IAAjB,KAA0B,YAAvC;AAAA,CAA5B;;AACA,IAAMwC,wBAAwB,GAAG,SAA3BA,wBAA2B,CAAC1D,OAAD;AAAA,SAAaA,OAAO,CAACY,QAAR,CAAiBM,IAAjB,KAA0B,iBAAvC;AAAA,CAAjC;;AACA,IAAMC,sBAAsB,GAAG,SAAzBA,sBAAyB,CAACnB,OAAD;AAAA,SAAayD,mBAAmB,CAACzD,OAAD,CAAnB,IAAgC0D,wBAAwB,CAAC1D,OAAD,CAArE;AAAA,CAA/B;;AACA,IAAM2B,gBAAgB,GAAG,SAAnBA,gBAAmB,CAAC3B,OAAD;AAAA,SAAaA,OAAO,CAACY,QAAR,CAAiBM,IAAjB,KAA0B,SAAvC;AAAA,CAAzB;;AACA,IAAMK,qBAAqB,GAAG,SAAxBA,qBAAwB,CAACvB,OAAD;AAAA,SAAaA,OAAO,CAACY,QAAR,CAAiBM,IAAjB,KAA0B,cAAvC;AAAA,CAA9B","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst React = __importStar(require(\"react\"));\nconst MapMarker_1 = __importDefault(require(\"./MapMarker\"));\nconst MapPolyline_1 = __importDefault(require(\"./MapPolyline\"));\nconst MapPolygon_1 = __importDefault(require(\"./MapPolygon\"));\nconst Geojson = (props) => {\n    const { geojson, strokeColor, fillColor, strokeWidth, color, title, image, zIndex, onPress, lineCap, lineJoin, tappable, tracksViewChanges, miterLimit, lineDashPhase, lineDashPattern, markerComponent, } = props;\n    const pointOverlays = makePointOverlays(geojson.features);\n    const lineOverlays = makeLineOverlays(geojson.features);\n    const polygonOverlays = makePolygonOverlays(geojson.features);\n    return (<React.Fragment>\n      {pointOverlays.map((overlay, index) => {\n            const markerColor = getColor(color, overlay, 'marker-color');\n            const pointOverlayTracksViewChanges = overlay.feature.properties?.tracksViewChanges || tracksViewChanges;\n            return (<MapMarker_1.default key={index} coordinate={overlay.coordinates} tracksViewChanges={pointOverlayTracksViewChanges} image={image} title={title} pinColor={markerColor} zIndex={zIndex} onPress={() => onPress && onPress(overlay)}>\n            {markerComponent}\n          </MapMarker_1.default>);\n        })}\n      {lineOverlays.map((overlay, index) => {\n            const lineStrokeColor = getColor(strokeColor, overlay, 'stroke');\n            const lineStrokeWidth = getStrokeWidth(strokeWidth, overlay);\n            return (<MapPolyline_1.default key={index} coordinates={overlay.coordinates} strokeColor={lineStrokeColor} strokeWidth={lineStrokeWidth} lineDashPhase={lineDashPhase} lineDashPattern={lineDashPattern} lineCap={lineCap} lineJoin={lineJoin} miterLimit={miterLimit} zIndex={zIndex} tappable={tappable} onPress={() => onPress && onPress(overlay)}/>);\n        })}\n      {polygonOverlays.map((overlay, index) => {\n            const polygonFillColor = getColor(fillColor, overlay, 'fill');\n            const lineStrokeColor = getColor(strokeColor, overlay, 'stroke');\n            const lineStrokeWidth = getStrokeWidth(strokeWidth, overlay);\n            return (<MapPolygon_1.default key={index} coordinates={overlay.coordinates} holes={overlay.holes} strokeColor={lineStrokeColor} fillColor={polygonFillColor} strokeWidth={lineStrokeWidth} tappable={tappable} onPress={() => onPress && onPress(overlay)} zIndex={zIndex}/>);\n        })}\n    </React.Fragment>);\n};\nexports.default = Geojson;\nconst makePointOverlays = (features) => {\n    return features\n        .filter(isAnyPointFeature)\n        .map(feature => makeCoordinatesForAnyPoint(feature.geometry).map(coordinates => makeOverlayForAnyPoint(coordinates, feature)))\n        .reduce((prev, curr) => prev.concat(curr), [])\n        .map(overlay => ({ ...overlay, type: 'point' }));\n};\nconst makeLineOverlays = (features) => {\n    return features\n        .filter(isAnyLineStringFeature)\n        .map(feature => makeCoordinatesForAnyLine(feature.geometry).map(coordinates => makeOverlayForAnyLine(coordinates, feature)))\n        .reduce((prev, curr) => prev.concat(curr), [])\n        .map(overlay => ({ ...overlay, type: 'polyline' }));\n};\nconst makePolygonOverlays = (features) => {\n    const multipolygons = features\n        .filter(isMultiPolygonFeature)\n        .map(feature => makeCoordinatesForMultiPolygon(feature.geometry).map(coordinates => makeOverlayForAnyPolygon(coordinates, feature)))\n        .reduce((prev, curr) => prev.concat(curr), [])\n        .map(overlay => ({ ...overlay, type: 'polygon' }));\n    const polygons = features\n        .filter(isPolygonFeature)\n        .map(feature => makeOverlayForAnyPolygon(makeCoordinatesForPolygon(feature.geometry), feature))\n        .reduce((prev, curr) => prev.concat(curr), [])\n        .map(overlay => ({ ...overlay, type: 'polygon' }));\n    return polygons.concat(multipolygons);\n};\nconst makeOverlayForAnyPoint = (coordinates, feature) => {\n    return { feature, coordinates };\n};\nconst makeOverlayForAnyLine = (coordinates, feature) => {\n    return { feature, coordinates };\n};\nconst makeOverlayForAnyPolygon = (coordinates, feature) => {\n    return {\n        feature,\n        coordinates: coordinates[0],\n        holes: coordinates.length > 1 ? coordinates.slice(1) : undefined,\n    };\n};\nconst makePoint = (c) => ({\n    latitude: c[1],\n    longitude: c[0],\n});\nconst makeLine = (l) => l.map(makePoint);\nconst makeCoordinatesForAnyPoint = (geometry) => {\n    if (geometry.type === 'Point') {\n        return [makePoint(geometry.coordinates)];\n    }\n    return geometry.coordinates.map(makePoint);\n};\nconst makeCoordinatesForAnyLine = (geometry) => {\n    if (geometry.type === 'LineString') {\n        return [makeLine(geometry.coordinates)];\n    }\n    return geometry.coordinates.map(makeLine);\n};\nconst makeCoordinatesForPolygon = (geometry) => {\n    return geometry.coordinates.map(makeLine);\n};\nconst makeCoordinatesForMultiPolygon = (geometry) => {\n    return geometry.coordinates.map(p => p.map(makeLine));\n};\nconst getRgbaFromHex = (hex, alpha = 1) => {\n    const matchArray = hex.match(/\\w\\w/g);\n    if (!matchArray || matchArray.length < 3) {\n        throw new Error('Invalid hex string');\n    }\n    const [r, g, b] = matchArray.map(x => {\n        const subColor = parseInt(x, 16);\n        if (Number.isNaN(subColor)) {\n            throw new Error('Invalid hex string');\n        }\n        return subColor;\n    });\n    return `rgba(${r},${g},${b},${alpha})`;\n};\nconst getColor = (prop, overlay, colorType) => {\n    if (prop) {\n        return prop;\n    }\n    let color = overlay.feature.properties?.[colorType];\n    if (color) {\n        const opacityProperty = colorType + '-opacity';\n        const alpha = overlay.feature.properties?.[opacityProperty];\n        if (alpha && alpha !== '0' && color[0] === '#') {\n            color = getRgbaFromHex(color, alpha);\n        }\n        return color;\n    }\n    return undefined;\n};\nconst getStrokeWidth = (prop, overlay) => {\n    if (prop) {\n        return prop;\n    }\n    return overlay.feature.properties?.['stroke-width'];\n};\n// GeoJSON.Feature type-guards\nconst isPointFeature = (feature) => feature.geometry.type === 'Point';\nconst isMultiPointFeature = (feature) => feature.geometry.type === 'MultiPoint';\nconst isAnyPointFeature = (feature) => isPointFeature(feature) || isMultiPointFeature(feature);\nconst isLineStringFeature = (feature) => feature.geometry.type === 'LineString';\nconst isMultiLineStringFeature = (feature) => feature.geometry.type === 'MultiLineString';\nconst isAnyLineStringFeature = (feature) => isLineStringFeature(feature) || isMultiLineStringFeature(feature);\nconst isPolygonFeature = (feature) => feature.geometry.type === 'Polygon';\nconst isMultiPolygonFeature = (feature) => feature.geometry.type === 'MultiPolygon';\n"]},"metadata":{},"sourceType":"script"}